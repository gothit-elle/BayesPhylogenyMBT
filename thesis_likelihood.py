# -*- coding: utf-8 -*-
"""thesis_likelihood.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PTrS3BzXHYtjg-0D1dG_isyQtwBxa2pz

Import relevant modules
"""

import numpy as np



import matplotlib.pyplot as plt

import warnings
from tqdm.notebook import tqdm
warnings.filterwarnings("error")


from tree import tree
from node import node
from likelihood import *



"""Build our parameter matrices"""



alpha = np.array([0.5,0.5]).astype(object)
d, D0, D1, B = build_mtrx(mu0= 0.15, mu1= 0.1, q01 = 0.2, q10 =0.7, lambda0 = 1, lambda1 = 0.5)
print(D0, B, d)


# Enter nodes and times by depth first traversal order (casing does not matter), with a fullstop following each. E.g. "T2.C18.G1.T8.A17.T9.T9." or "2T.1G.17A.8T.9T.9T.18C." etc
# nodeStr = "T2.C18.G1.T8.A17.T9.T9."






nodeStr = "2A.1T.17C.8G.9G.9T.18A." # nodes and branch lengths
t=20 # obs time
trees= []
t2=Tree(1)
t2.str2tree(nodeStr,t,by='df')
t2.disp()

t_current = t2
t_new= q_ratio = -1
for i in range(20):
  move = propose_move(t_current,alpha, d, D0, B, i)

  if move != EXIT_FAILURE:
    t_new, q_ratio, alpha, d, D0, B = move
    trees.append(t_new)

"""# MCMC chain"""

plot=0
treestrings = []
for tree in trees:
  treestrings.append(tree.toStr())
treestrings = list(set(treestrings))
for i in treestrings:
  s = i
  t_cur = Tree(1)
  t_cur.str2tree(s,t,by='io')
  t_cur.disp()
  print(i)



t2 = Tree(1)
k = 847

print(chain3a[k])
print(chain3b[k])
t2.str2tree(chain3a[k], by='io')
t2.disp()
print(chain3b[k-5:k+5])

alpha, d, D0, B = chain3c[k]
#alpha = np.array([0.5,0.5]).astype(object)
#d, D0, D1, B = build_mtrx(mu0= 0.1, mu1= 0.1, q01 = 0.9, q10 =0.001, lambda0 = 1, lambda1 = 0.099)
print(alpha)
print(D0)
print(d)
print(B)

#print(tree_posterior(t2, alpha, d, D0, B, Q1)) # why is this different?

plot=0
plt.plot(range(N+1), chain1b, range(N+1), chain2b, range(N+1), chain3b) #, range(N+1), chain4b)
params = {'mathtext.default': 'regular' }
plt.rcParams.update(params)
plt.xlabel('Step')
plt.ylabel('Posterior Log-Likelihood')
plt.title("Posterior Log-likelihood vs MCMC Step")
plt.legend(["Chain 1", "Chain 2", "Chain 3", "Chain 4"], loc="lower left")

t2 = Tree(1)
k = 292

print(chain4a[k])
print(chain4b[k])
t2.str2tree(chain4a[k], by='io')
t2.disp()
print(chain4b[k-2:k+2])
alpha, d, D0, B = chain1c[k]
#alpha = np.array([0.5,0.5]).astype(object)
#d, D0, D1, B = build_mtrx(mu0= 0.1, mu1= 0.1, q01 = 0.9, q10 =0.001, lambda0 = 1, lambda1 = 0.099)
print(alpha)
print(D0)
print(d)
print(B)

# print(tree_posterior(t2, alpha, d, D0, B, Q1))

t2 = Tree(1)
k = 9

print(chain2a[k])
print(chain2b[k])
t2.str2tree(chain2a[k], by='io')
t2.disp()
print(chain2c[k-2:k+2])
print(chain2b[k-2:k+2])
alpha, d, D0, B = chain2c[k]
#alpha = np.array([0.5,0.5]).astype(object)
#d, D0, D1, B = build_mtrx(mu0= 0.1, mu1= 0.1, q01 = 0.9, q10 =0.001, lambda0 = 1, lambda1 = 0.099)
print(alpha)
print(D0)
print(d)
print(B)

# print(tree_posterior(t2, alpha, d, D0, B, Q1))



print("d", d)
print(D0)
print(B)
print("a", alpha)

evals, evecs = np.linalg.eigh((np.linalg.inv(-D0.astype(np.float64))@B@np.transpose(np.kron(np.ones(2), np.identity(2)) + np.kron(np.identity(2), np.ones(2)))).astype(np.float64))
print(evals) # lambda < 1 so E is maximum of 1